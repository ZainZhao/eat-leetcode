- Q

```markdown
给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。

num1 和num2 的长度都小于 5100
num1 和num2 都只包含数字 0-9
num1 和num2 都不包含任何前导零
你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式

```



- 

```java
class Solution {
    public String addStrings(String num1, String num2) {
        char[] array1 = num1.toCharArray();
        char[] array2 = num2.toCharArray();

        int curr1 = 0;
        int curr2 = 0;
        int flag = 0;
        
        StringBuilder stringBuilder = new StringBuilder();

        while (curr1 <= array1.length || curr2 <= array2.length || flag != 0) {
            sum = int()array1[curr1] + int()array2[curr2];

            stringBuilder.append(array1[curr2]);
            
        }
    }
}
```

- 两次遍历HashMap

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
         Map<Integer, Integer> map = new HashMap<>(); // 这里必须显示定义出Map K V的类型，防止后面使用-时重复进行强转
         // 先插入
         for (int i=0;i < nums.length;i++) {
             map.put(nums[i],i);
         }
         // 再遍历查找
         for (int i=0; i < nums.length; i++) {
             int diff = target - nums[i];
             if (map.containsKey(diff) && map.get(diff) != i) {  // 防止出现自己加自己的情况
                 return new int[] {i, map.get(diff)};
             }
         }
         return null;
    }
}
```

- 一次遍历

```java
// 边插入，边遍历查找
class Solution {
    public int[] twoSum(int[] nums, int target) {

        Map<Integer,Integer> map = new HashMap<>();

        for (int i = 0; i < nums.length ; i++) {
            int diff = target - nums[i];
            if (map.containsKey(diff)) {  // 因为插入在判断之后，所以不用防止自己加自己的情况
                return new int[] {map.get(diff), i};
            }
            map.put(nums[i], i);
        }

        throw new IllegalArgumentException("no solution");
    
    }
}
```



## 特殊







- python

  ```python
  # 暴力法
  class Solution:
      def twoSum(self, nums: List[int], target: int) -> List[int]:
          for i_index,i in enumerate(nums):
              for j_index,j in enumerate(nums):
                  if i+j==target and i_index!=j_index:
                      return [i_index,j_index]
          return None
  ```

  ```python
  # Hash 一次
  class Solution:
      def twoSum(self, nums: List[int], target: int) -> List[int]:
          dic = {}
          for i_index,i_value in enumerate(nums):
              diff = target - i_value  
              if diff in dic.keys():
                  return [i_index,dic.get(diff)]
              dic[i_value] = i_index
          return None
  ```

  